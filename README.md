This is a web queue worker library inspired by a Derek Comartin video [Web-Queue-Worker Architecture Style for Scaling](https://www.youtube.com/watch?v=niAA3bprjNU). I've done some work with background services [BackgroundService.Extensions](https://github.com/adamfoneil/BackgroundService.Extensions), but hadn't done anything with multiple, coordinated workers. I've played a little bit recently with [Coravel](https://github.com/jamesmh/coravel), and it has a nice queueing feature. But as usual, I wanted to try thinking through the problem myself just to get my head around it.

At the heart of this are some [interfaces](https://github.com/adamfoneil/AsyncWorkflow/tree/master/AsyncWorkflow/Interfaces):
- [IQueue](https://github.com/adamfoneil/AsyncWorkflow/blob/master/AsyncWorkflow/Interfaces/IQueue.cs) defines fundamental operations on a persistent queue of some kind
- [IStatusRepository](https://github.com/adamfoneil/AsyncWorkflow/blob/master/AsyncWorkflow/Interfaces/IStatusRepository.cs) defines a standard way of tracking success, failure, or any kind of process outcome for all workers
- [ITrackedPayload](https://github.com/adamfoneil/AsyncWorkflow/blob/master/AsyncWorkflow/Interfaces/ITrackedPayload.cs) is something you'd implement on a payload model that you need to identify uniquely

The actual `BackgroundService` implementation is [WorkflowBackgroundService](https://github.com/adamfoneil/AsyncWorkflow/blob/master/AsyncWorkflow/WorkflowBackgroundService.cs). A few key points:
- The first thing to look at is the [ProcessNextMessageAsync](https://github.com/adamfoneil/AsyncWorkflow/blob/master/AsyncWorkflow/WorkflowBackgroundService.cs#L34) call. This is where the worker is doing its main work within the `BackgroundService.ExecuteAsync` loop, which is running continually [until canceled](https://github.com/adamfoneil/AsyncWorkflow/blob/master/AsyncWorkflow/WorkflowBackgroundService.cs#L29).
- The outcome of that work recorded with [Status.SetAsync](https://github.com/adamfoneil/AsyncWorkflow/blob/master/AsyncWorkflow/WorkflowBackgroundService.cs#L43). This captures the duration, status result, and name of the worker (handler) that did the work.
- When work is done, the worker has a chance to define what happens next with the [OnCompletedAsync](https://github.com/adamfoneil/AsyncWorkflow/blob/master/AsyncWorkflow/WorkflowBackgroundService.cs#L53) method. This is gives us a chance to coordinate sequential and parallel work.
- The dequeing of messages and parsing json payload data happens in [ProcessNextMessageAsync](https://github.com/adamfoneil/AsyncWorkflow/blob/master/AsyncWorkflow/WorkflowBackgroundService.cs#L68). We'll see the implementation of this shortly. Note that I use the current `MachineName` as an argument. This is the best way I know to ensure that concurrent workers don't do redundant work. By filtering queue reads by machine name, you can have as many different worker machines as you want, and they won't step on each other. The dequeue implementation also really matters here as well. When querying queue messages from a database table (for example), there are some special considerations to prevent duplicate query results that we'll see shortly. The `HandlerName` is really just the class name -- used as a filter to target queue messages to the appropriate handler.
- The [ProcessMessageAsync](https://github.com/adamfoneil/AsyncWorkflow/blob/master/AsyncWorkflow/WorkflowBackgroundService.cs#L80) call is the abstract method where you supply the implementation of the work you're doing.
- As of this writing, I did not get around to implementing queue read [failures](https://github.com/adamfoneil/AsyncWorkflow/blob/master/AsyncWorkflow/WorkflowBackgroundService.cs#L85), please note.
